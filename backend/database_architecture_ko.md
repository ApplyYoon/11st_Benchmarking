# 차세대 데이터베이스 아키텍처 계획

이 문서는 향후 진행될 데이터베이스 마이그레이션(이전)을 위한 아키텍처 구현 계획을 설명합니다. 주요 목표는 데이터베이스 역할을 명확히 분리하고, 고객의 평생 주문 내역을 지연 없이 저장하고 조회할 수 있도록 확장성을 확보하는 것입니다.

## 1. 데이터베이스 분리
전체 시스템 데이터는 다음과 같이 세 개의 독립적인 데이터베이스 도메인으로 분리됩니다:

### **1. 사용자 데이터베이스 (`User_DB`)**
- **목적**: 사용자 프로필 및 인증 정보 전용 저장소.
- **주요 필드**: `userId` (기본키), `username`, `password`, `email` 등.

### **2. 상품 데이터베이스 (`Product_DB`)**
- **목적**: 상품 정보의 중앙화된 카탈로그.
- **주요 필드**: `productId` (기본키), `name`, `price`, `category`, `stock` 등.

### **3. 주문 데이터베이스 (`Order_DB`)**
- **목적**: 모든 주문 내역의 영구 보관.
- **유형**: **NoSQL** (대규모 데이터 처리와 유연한 스키마 구조를 위해 선정).

---

## 2. Order_DB 아키텍처 전략

`Order_DB`는 대용량 주문 내역을 빠르고 안정적으로 처리하기 위해 특별한 **샤딩(Sharding)** 및 **파티셔닝(Partitioning)** 전략을 사용합니다.

### **A. 수평 샤딩 (User ID 기준)**
부하를 분산시키기 위해 `userId`를 기준으로 데이터를 물리적으로 서로 다른 데이터베이스 서버에 나누어 저장합니다.

- **로직**: 모듈로(Modulo) 샤딩
  - **샤드 A (Shard A)**: **홀수** ID를 가진 사용자의 주문 내역 저장 (예: 1, 3, 5...).
  - **샤드 B (Shard B)**: **짝수** ID를 가진 사용자의 주문 내역 저장 (예: 2, 4, 6...).
- **이점**: 쓰기 및 읽기 부하를 여러 서버로 균등하게 분산시킵니다.

### **B. 수직 파티셔닝 (년도 기준)**
각 샤드 내부에서 데이터는 시간(년도)을 기준으로 다시 한번 나누어 저장됩니다. 이는 인덱스 크기를 최적화하고 쿼리 속도를 유지하기 위함입니다.

- **로직**: 주문 날짜 기반 범위(Range) 파티셔닝.
  - `Order_2023` (컬렉션/테이블)
  - `Order_2024` (컬렉션/테이블)
  - `Order_2025` (컬렉션/테이블)
- **이점**: 과거 데이터가 쌓여도 최근 데이터 조회 속도에 영향을 주지 않습니다. 데이터 아카이빙(보관)이 매우 수월해집니다.

---

## 3. 데이터 흐름 및 구현 참고사항

### **쓰기 경로 (주문 생성 시)**
1.  **입력**: 사용자 `101`번이 상품 `50`번을 주문.
2.  **라우팅**:
    - `userId`가 `101` (홀수) → **샤드 A**로 라우팅.
    - 현재 연도가 `2025`년 → **`Order_2025`** 파티션 선택.
3.  **저장**: 문서 저장 `{ "userId": 101, "productId": 50, "date": "2025-12-13", ... }`.

### **읽기 경로 (내역 조회 시)**
1.  **입력**: 사용자 `102`번의 주문 내역 조회.
2.  **라우팅**:
    - `userId`가 `102` (짝수) → **샤드 B**로 연결.
3.  **집계 (Aggregation)**:
    - UI 요구사항에 따라 `Order_2025`, `Order_2024` 등을 병렬로 조회하거나 필요한 부분만 순차적으로 조회.

## 4. 구현 프롬프트 (미래의 AI를 위해)
> **사용자가 "이 데이터베이스 계획을 구현해줘"라고 요청할 경우:**
> 1. 이 문서를 참조할 것.
> 2. NoSQL 컨테이너들을 실행할 것 (예: MongoDB 샤드 클러스터 또는 개별 인스턴스).
> 3. 백엔드(Spring Boot)에 `홀수/짝수` 라우팅 로직을 처리하는 데이터베이스 라우터/리졸버를 구현할 것.
> 4. 현재 연도에 따라 동적으로 컬렉션/테이블을 선택하는 로직을 구현할 것.
